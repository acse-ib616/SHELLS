#include <iostream>
#include <math.h>
#include <chrono>
#include <vector>
#include <memory>
#include "Matrix.h"
#include "Matrix.cpp"
#include "CSRMatrix.h"
#include "CSRMatrix.cpp"
#include "SparseSolver.h"
#include "SparseSolver.cpp"
#include "utilities.h"
#include <memory>
#include <numeric>
#include "mex.hpp"        // for the C++ MEX API.
#include "mexAdapter.hpp" // for the implementation of MexFunction class

class MexFunction : public matlab::mex::Function
{
public:
    void operator()(matlab::mex::ArgumentList outputs, matlab::mex::ArgumentList inputs)
    {
        checkArguments(outputs, inputs);
        double E = inputs[0][0];  // Young's Modulus,
        double nu = inputs[1][0]; // Poisson coefficient
        double t = inputs[2][0];  // Thickness of shell

        // Change inputs into vectors, which are easier to manipulate in C++ and can link with sparse solvers
        // and matrix classes. Values are stored in ROW-MAJOR order in the vectors (A[i][j] = v[i*columns +j])
        matlab::data::TypedArray<double> F_Array = std::move(inputs[3]);
        std::vector<double> F(F_array.begin(), F_array.end()); // Force nodal vector

        matlab::data::TypedArray<double> coords_Array = std::move(inputs[4]);
        std::vector<double> node_coords(coords_Array.begin(), coords_Array.end()); // Node coordinates

        matlab::data::TypedArray<int> els_Array = std::move(inputs[5]);
        std::vector<int> ELEMENTS(els_Array.begin(), els_Array.end()); // Nodal connectivity

        matlab::data::TypedArray<int> dfree_Array = std::move(inputs[6]);
        std::vector<int> dofs_free(dfree_Array.begin(), dfree_Array.end()); // FREE dofs

        matlab::data::TypedArray<int> drest_Array = std::move(inputs[7]);
        std::vector<int> dofs_restrained(drest_Array.begin(), drest_Array.end()); // FIXED dofs
        // arrayProduct(in, multiplier);
        // outputs[0] = std::move(in);
    }

    std::shared_ptr<int[]> init_row_position1(new int[size + 1]{0, 2, 4, 7, 11, 14});
    std::shared_ptr<int[]> init_col_index1(new int[nnzs]{0, 4, 0, 1, 1, 2, 3, 0, 2, 3, 4, 1, 3, 4});
    std::shared_ptr<double[]> init_sparse_values1(new double[nnzs]{10, -2, 3, 9, 7, 8, 7, 3, 8, 7, 5, 8, 9, 13});
    CSRMatrix<double> sparse_matrix = CSRMatrix<double>(size, size, nnzs, init_sparse_values1, init_row_position1, init_col_index1);
    Matrix<double> m = Matrix<double>(size, size, values);

    void arrayProduct(matlab::data::TypedArray<double> &inMatrix, double multiplier)
    {

        for (auto &elem : inMatrix)
        {
            elem *= multiplier;
        }
    }

    void checkArguments(matlab::mex::ArgumentList outputs, matlab::mex::ArgumentList inputs)
    {
        std::shared_ptr<matlab::engine::MATLABEngine> matlabPtr = getEngine();
        matlab::data::ArrayFactory factory;

        if (inputs.size() != 2)
        {
            matlabPtr->feval(u"error",
                             0, std::vector<matlab::data::Array>({factory.createScalar("Two inputs required")}));
        }

        if (inputs[0].getNumberOfElements() != 1)
        {
            matlabPtr->feval(u"error",
                             0, std::vector<matlab::data::Array>({factory.createScalar("Input multiplier must be a scalar")}));
        }

        if (inputs[0].getType() != matlab::data::ArrayType::DOUBLE ||
            inputs[0].getType() == matlab::data::ArrayType::COMPLEX_DOUBLE)
        {
            matlabPtr->feval(u"error",
                             0, std::vector<matlab::data::Array>({factory.createScalar("Input multiplier must be a noncomplex scalar double")}));
        }

        if (inputs[3].getType() != matlab::data::ArrayType::DOUBLE ||
            inputs[3].getType() == matlab::data::ArrayType::COMPLEX_DOUBLE)
        {
            matlabPtr->feval(u"error",
                             0, std::vector<matlab::data::Array>({factory.createScalar("Input matrix must be type double")}));
        }

        if (inputs[3].getDimensions().size() != 2)
        {
            matlabPtr->feval(u"error",
                             0, std::vector<matlab::data::Array>({factory.createScalar("Input must be m-by-n dimension")}));
        }
    }
};

std::vector<double> k_CST(double nu, double E, double t, double x1, double x2, double x3, double y1, double y2, double y3)
{
    // The following block of code has been generated by Maple's CodeGeneration
    k[0] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * (pow(y2 - y3, 0.2e1) + pow(-x2 + x3, 0.2e1) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1)) / 0.2e1;
    k[1] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (double)nu * (-x2 + x3) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y2 - y3)) / 0.2e1;
    k[2] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (-y1 + y3) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (x1 - x3)) / 0.2e1;
    k[3] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (double)nu * (x1 - x3) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-y1 + y3)) / 0.2e1;
    k[4] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (y1 - y2) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[5] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (double)nu * (-x1 + x2) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[1 * 6] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (double)nu * (-x2 + x3) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y2 - y3)) / 0.2e1;
    k[1 * 6 + 1] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * (pow(-x2 + x3, 0.2e1) + pow(y2 - y3, 0.2e1) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1)) / 0.2e1;
    k[1 * 6 + 2] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (double)nu * (-y1 + y3) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (x1 - x3)) / 0.2e1;
    k[1 * 6 + 3] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (x1 - x3) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-y1 + y3)) / 0.2e1;
    k[1 * 6 + 4] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (double)nu * (y1 - y2) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[1 * 6 + 5] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (-x1 + x2) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[2 * 6] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (-y1 + y3) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (x1 - x3)) / 0.2e1;
    k[2 * 6 + 1] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (double)nu * (-y1 + y3) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (x1 - x3)) / 0.2e1;
    k[2 * 6 + 2] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * (pow(-y1 + y3, 0.2e1) + pow(x1 - x3, 0.2e1) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1)) / 0.2e1;
    k[2 * 6 + 3] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-y1 + y3) * (double)nu * (x1 - x3) + (x1 - x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-y1 + y3)) / 0.2e1;
    k[2 * 6 + 4] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-y1 + y3) * (y1 - y2) + (x1 - x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[2 * 6 + 5] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-y1 + y3) * (double)nu * (-x1 + x2) + (x1 - x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[3 * 6] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (double)nu * (x1 - x3) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-y1 + y3)) / 0.2e1;
    k[3 * 6 + 1] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (x1 - x3) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-y1 + y3)) / 0.2e1;
    k[3 * 6 + 2] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-y1 + y3) * (double)nu * (x1 - x3) + (x1 - x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-y1 + y3)) / 0.2e1;
    k[3 * 6 + 3] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * (pow(x1 - x3, 0.2e1) + pow(-y1 + y3, 0.2e1) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1)) / 0.2e1;
    k[3 * 6 + 4] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((x1 - x3) * (double)nu * (y1 - y2) + (-y1 + y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[3 * 6 + 5] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((x1 - x3) * (-x1 + x2) + (-y1 + y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[4 * 6] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (y1 - y2) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[4 * 6 + 1] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (double)nu * (y1 - y2) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[4 * 6 + 2] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-y1 + y3) * (y1 - y2) + (x1 - x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[4 * 6 + 3] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((x1 - x3) * (double)nu * (y1 - y2) + (-y1 + y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (-x1 + x2)) / 0.2e1;
    k[4 * 6 + 4] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * (pow(y1 - y2, 0.2e1) + pow(-x1 + x2, 0.2e1) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1)) / 0.2e1;
    k[4 * 6 + 5] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y1 - y2) * (double)nu * (-x1 + x2) + (-x1 + x2) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[5 * 6] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y2 - y3) * (double)nu * (-x1 + x2) + (-x2 + x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[5 * 6 + 1] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-x2 + x3) * (-x1 + x2) + (y2 - y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[5 * 6 + 2] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((-y1 + y3) * (double)nu * (-x1 + x2) + (x1 - x3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[5 * 6 + 3] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((x1 - x3) * (-x1 + x2) + (-y1 + y3) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[5 * 6 + 4] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * ((y1 - y2) * (double)nu * (-x1 + x2) + (-x1 + x2) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1) * (y1 - y2)) / 0.2e1;
    k[5 * 6 + 5] = E * t / (double)(-nu * nu + 1) / (x1 * y2 - x1 * y3 - x2 * y1 + x2 * y3 + x3 * y1 - x3 * y2) * (pow(-x1 + x2, 0.2e1) + pow(y1 - y2, 0.2e1) * (0.1e1 / 0.2e1 - (double)nu / 0.2e1)) / 0.2e1;

    return k;
}

CSRMatrix<double> construct_K_CST(double nu, double E, double t, std::vector<double> node_coords, std::vector<double> ELEMENTS)
{
    int els = ELEMENTS.size() / 3;      // Number of elements
    int nodes = node_coords.size() / 2; // Number of nodes
    int n_dofs = node_coords.size();    // Number of DOFs
    double x1, x2, x3, y1, y2, y3;
    int n1, n2, n3, dof11, dof12, dof21, dof22, dof31, dof32;

    std::vector<double> values;                   // Non-zero values of stiffness matrix
    std::vector<int> col_index;                   // Column indices of nnz values of stiffness matrix
    std::vector<int> row_position(n_dofs + 1, 0); // Indices in nnz values of stiffness matrix at start of each row

    // Create vector of DOFs
    std::vector<int> dofs(n_dofs);
    std::iota(std::begin(dofs), std::end(dofs), 0);

    for (int i = 0; i < els; i++)
    {
        // Identify element node numbers
        n1 = ELEMENTS[i * 3];
        n2 = ELEMENTS[i * 3 + 1];
        n3 = ELEMENTS[i * 3 + 2]; // element node 3 - x,y coordinates

        // element node 1 - x,y coordinates
        x1 = node_coords[n1 * 2];
        y1 = node_coords[n1 * 2 + 1];
        // element node 2 - x,y coordinates
        x2 = node_coords[n2 * 2];
        y2 = node_coords[n2 * 2 + 1];
        // element node 3 - x,y coordinates
        x3 = node_coords[n3 * 2];
        y3 = node_coords[n3 * 2 + 1];

        // element node 1 - dofs
        dof11 = dofs[n1 * 2];
        dof12 = dofs[n1 * 2 + 1];
        // element node 2 - dofs
        dof21 = dofs[n2 * 2];
        dof22 = dofs[n2 * 2 + 1];
        // element node 3 - dofs
        dof31 = dofs[n3 * 2];
        dof32 = dofs[n3 * 2 + 1];

        // Element stiffness matrix
        std::vector<double> ke = k_CST(nu, E, t, x1, x2, x3, y1, y2, y3);
    }
}

/*
for EL = 1:elements % loop through all elements & build stiffness matrix
    n1 = ELEMENTS(EL,1); n2 = ELEMENTS(EL,2); % identify element node numbers
    n3 = ELEMENTS(EL,3);
    x1 = NODES.coords(n1,1); y1 = NODES.coords(n1,2); % element node 1 - x,y coordinates
    x2 = NODES.coords(n2,1); y2 = NODES.coords(n2,2); % element node 2 - x,y coordinates
    x3 = NODES.coords(n3,1); y3 = NODES.coords(n3,2); % element node 3 - x,y coordinates
    
    dof11 = NODES.dofs(n1,1); dof12 = NODES.dofs(n1,2); % element node 1 - dofs
    dof21 = NODES.dofs(n2,1); dof22 = NODES.dofs(n2,2); % element node 2 - dofs
    dof31 = NODES.dofs(n3,1); dof32 = NODES.dofs(n3,2); % element node 3 - dofs
    
    constants = E*t/(1-nu^2); % Plane stress condition

    ke = k_CST(x1,x2,x3,y1,y2,y3,nu,r(m),s(n));   
    ke = constants*ke; % element stiffness. The 0.5 comes from integrating the area of a triangle (bh/2)
    
    % Updating global stiffness matrix [K] coefficients 
    % Note that for each element you still have to 'think locally'
    % Row 1 - element dof11
    K(dof11,dof11) = K(dof11,dof11) + ke(1,1); % Col 1 - element dof11
    K(dof11,dof12) = K(dof11,dof12) + ke(1,2); % Col 2 - element dof12
    K(dof11,dof21) = K(dof11,dof21) + ke(1,3); % Col 3 - element dof21
    K(dof11,dof22) = K(dof11,dof22) + ke(1,4); % Col 4 - element dof22
    K(dof11,dof31) = K(dof11,dof31) + ke(1,5); % Col 5 - element dof31
    K(dof11,dof32) = K(dof11,dof32) + ke(1,6); % Col 6 - element dof32
    
    % Row 2 - element dof12
    K(dof12,dof11) = K(dof12,dof11) + ke(2,1); % Col 1 - element dof11
    K(dof12,dof12) = K(dof12,dof12) + ke(2,2); % Col 2 - element dof12
    K(dof12,dof21) = K(dof12,dof21) + ke(2,3); % Col 3 - element dof21
    K(dof12,dof22) = K(dof12,dof22) + ke(2,4); % Col 4 - element dof22
    K(dof12,dof31) = K(dof12,dof31) + ke(2,5); % Col 5 - element dof31
    K(dof12,dof32) = K(dof12,dof32) + ke(2,6); % Col 6 - element dof32
    
    % Row 3 - element dof21
    K(dof21,dof11) = K(dof21,dof11) + ke(3,1); % Col 1 - element dof11
    K(dof21,dof12) = K(dof21,dof12) + ke(3,2); % Col 2 - element dof12
    K(dof21,dof21) = K(dof21,dof21) + ke(3,3); % Col 3 - element dof21
    K(dof21,dof22) = K(dof21,dof22) + ke(3,4); % Col 4 - element dof22
    K(dof21,dof31) = K(dof21,dof31) + ke(3,5); % Col 5 - element dof31
    K(dof21,dof32) = K(dof21,dof32) + ke(3,6); % Col 6 - element dof32
    
    % Row 4 - element dof22
    K(dof22,dof11) = K(dof22,dof11) + ke(4,1); % Col 1 - element dof11
    K(dof22,dof12) = K(dof22,dof12) + ke(4,2); % Col 2 - element dof12
    K(dof22,dof21) = K(dof22,dof21) + ke(4,3); % Col 3 - element dof21
    K(dof22,dof22) = K(dof22,dof22) + ke(4,4); % Col 4 - element dof22
    K(dof22,dof31) = K(dof22,dof31) + ke(4,5); % Col 5 - element dof31
    K(dof22,dof32) = K(dof22,dof32) + ke(4,6); % Col 6 - element dof32
    
    % Row 5 - element dof31
    K(dof31,dof11) = K(dof31,dof11) + ke(5,1); % Col 1 - element dof11
    K(dof31,dof12) = K(dof31,dof12) + ke(5,2); % Col 2 - element dof12
    K(dof31,dof21) = K(dof31,dof21) + ke(5,3); % Col 3 - element dof21
    K(dof31,dof22) = K(dof31,dof22) + ke(5,4); % Col 4 - element dof22
    K(dof31,dof31) = K(dof31,dof31) + ke(5,5); % Col 5 - element dof31
    K(dof31,dof32) = K(dof31,dof32) + ke(5,6); % Col 6 - element dof32
    
    % Row 6 - element dof32
    K(dof32,dof11) = K(dof32,dof11) + ke(6,1); % Col 1 - element dof11
    K(dof32,dof12) = K(dof32,dof12) + ke(6,2); % Col 2 - element dof12
    K(dof32,dof21) = K(dof32,dof21) + ke(6,3); % Col 3 - element dof21
    K(dof32,dof22) = K(dof32,dof22) + ke(6,4); % Col 4 - element dof22
    K(dof32,dof31) = K(dof32,dof31) + ke(6,5); % Col 5 - element dof31
    K(dof32,dof32) = K(dof32,dof32) + ke(6,6); % Col 6 - element dof32
    
    
end

% Constructing the global nodal force vector
F = zeros(2*nodes,1); % initialising en empty a 12x1 column vector for convenience
F(N+1) = -1e5; % The load P acts downwards on node 26 i.e. it affects global dof 2*26
% There are no other nodal loads to apply

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%% SOLVER MODULE %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Specification of submatrices directly, note there is no need to form
% a rearranged K or F explicitly
KRR = K(dofs_restrained,dofs_restrained);
KRF = K(dofs_restrained,dofs_free);
KFR = K(dofs_free,dofs_restrained);
KFF = K(dofs_free,dofs_free);
fF = F(dofs_free);
% You cannot yet form fR as you do not know what the base reaction is.
% Also, you can even avoid formulating KRR etc. separately and just access
% the requires sub-matrices of K and f directly in what follows.

% Solution for the unknown nodal dofs
uR = zeros(length(dofs_restrained),1); % BC - zero displacement on nodes 1,2,3,4,5,6,7,8,11,12
uF = KFF\(fF - KFR*uR); % 1st matrix equation
U = zeros(2*nodes,1);
U(dofs_restrained) = uR;
U(dofs_free) = uF; % full nodal dof vector

% Solution for the unknown reactions
fR = KRF*uF + KRR*uR; % 2nd matrix equation
F(dofs_restrained) = fR; % full nodal force vector
*/